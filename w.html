<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D鞋子模型展示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('./w_background.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.6;
            z-index: -1;
            pointer-events: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 100;
        }
        
        #loading .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 16px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>正在加载3D模型...</div>
        </div>
        
        <div id="error">
            <h3>加载失败</h3>
            <p id="error-message"></p>
            <p>请确保w.glb文件在同一目录下</p>
        </div>
        
        <div id="instructions">
            <div><strong>操作说明：</strong></div>
            <div>• 鼠标左键拖拽：旋转模型</div>
            <div>• 鼠标滚轮：缩放模型</div>
            <div>• 鼠标右键拖拽：移动模型</div>
        </div>
    </div>

    <!-- 引入Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- 引入OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let loadingElement = document.getElementById('loading');
        let errorElement = document.getElementById('error');
        let container = document.getElementById('container');

        // 初始化3D场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            // 不设置场景背景，让它透明以显示页面背景

            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, 5);

            // 创建渲染器（设置为透明以显示背景图片）
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true, // 启用透明度
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // 超亮渲染设置
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ReinhardToneMapping; // 更亮的色调映射
            renderer.toneMappingExposure = 3.0; // 大幅增加曝光度
            renderer.physicallyCorrectLights = true;
            
            // 启用HDR支持
            renderer.gammaFactor = 2.2;
            
            // 设置渲染器透明度，让背景图片可见
            renderer.setClearColor(0x000000, 0); // 透明背景
            
            container.appendChild(renderer.domElement);

            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.enableRotate = true;

            // 添加光照
            setupLighting();

            // 加载3D模型
            loadModel();

            // 开始渲染循环
            animate();

            // 监听窗口大小变化
            window.addEventListener('resize', onWindowResize, false);
        }

        // 设置光照
        function setupLighting() {
            // 超强环境光 - 提供整体亮度
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);

            // 主光源 - 从右上方照射，超高强度
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight1.position.set(10, 10, 5);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            scene.add(directionalLight1);

            // 补充光源 - 从左下方照射，减少阴影
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight2.position.set(-10, -5, -5);
            scene.add(directionalLight2);

            // 前方补光 - 照亮正面
            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 1.8);
            directionalLight3.position.set(0, 0, 10);
            scene.add(directionalLight3);

            // 顶部光源 - 增加顶部亮度
            const directionalLight4 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight4.position.set(0, 15, 0);
            scene.add(directionalLight4);

            // 底部光源 - 减少底部阴影
            const directionalLight5 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight5.position.set(0, -10, 0);
            scene.add(directionalLight5);

            // 添加半球光 - 模拟天空光照
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x888888, 1.5);
            scene.add(hemisphereLight);
        }

        // 加载3D模型
        function loadModel() {
            console.log('开始加载模型...');
            console.log('当前URL:', window.location.href);
            console.log('模型路径: ./w.glb');
            
            const loader = new THREE.GLTFLoader();
            
            // 首先检查文件是否可访问
            fetch('./w.glb')
                .then(response => {
                    console.log('Fetch响应状态:', response.status, response.statusText);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.blob();
                })
                .then(blob => {
                    console.log('文件大小:', blob.size, 'bytes');
                    console.log('文件类型:', blob.type);
                    
                    // 创建临时URL
                    const url = URL.createObjectURL(blob);
                    console.log('临时URL创建成功:', url);
                    
                    // 使用临时URL加载模型
                    loader.load(
                        url,
                        function(gltf) {
                            console.log('GLTF加载成功:', gltf);
                            
                            // 加载成功
                            const model = gltf.scene;
                            
                            // 计算模型边界盒，用于自动调整大小和位置
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            
                            console.log('模型尺寸:', size);
                            console.log('模型中心:', center);
                            
                            // 将模型居中
                            model.position.x = -center.x;
                            model.position.y = -center.y;
                            model.position.z = -center.z;
                            
                            // 调整相机位置以适应模型大小
                            const maxDim = Math.max(size.x, size.y, size.z);
                            camera.position.set(0, 0, maxDim * 2);
                            controls.target.set(0, 0, 0);
                            
                            // 设置控制器限制
                            controls.minDistance = maxDim * 0.5;
                            controls.maxDistance = maxDim * 5;
                            
                            // 启用阴影和大幅优化材质
                            model.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    // 大幅提升材质亮度
                                    if (child.material) {
                                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                                        
                                        materials.forEach(material => {
                                            // 保持原始的PBR材质属性
                                            if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                                                material.roughness = Math.max(0.05, material.roughness || 0.3); // 更光滑
                                                material.metalness = material.metalness || 0;
                                                material.envMapIntensity = 2.0; // 增强环境映射
                                            }
                                            
                                            // 确保材质使用sRGB编码
                                            if (material.map) {
                                                material.map.encoding = THREE.sRGBEncoding;
                                                material.map.flipY = false;
                                            }
                                            
                                            // 大幅提升颜色亮度
                                            if (material.color) {
                                                const hsl = {};
                                                material.color.getHSL(hsl);
                                                // 对所有颜色都进行提亮处理
                                                let newLightness = hsl.l;
                                                if (hsl.l < 0.7) {
                                                    newLightness = Math.min(0.9, hsl.l + 0.4); // 大幅提亮
                                                }
                                                // 增强饱和度让颜色更鲜艳
                                                const newSaturation = Math.min(1.0, hsl.s + 0.2);
                                                material.color.setHSL(hsl.h, newSaturation, newLightness);
                                            }
                                            
                                            // 如果有自发光属性，增强它
                                            if (material.emissive) {
                                                material.emissive.multiplyScalar(1.5);
                                            }
                                            
                                            material.needsUpdate = true;
                                        });
                                    }
                                    
                                    console.log('大幅优化网格:', child.name || 'unnamed', '材质数量:', Array.isArray(child.material) ? child.material.length : 1);
                                }
                            });
                            
                            scene.add(model);
                            
                            // 释放临时URL
                            URL.revokeObjectURL(url);
                            
                            // 隐藏加载提示
                            loadingElement.style.display = 'none';
                            
                            console.log('模型加载并添加到场景成功');
                        },
                        function(progress) {
                            // 加载进度
                            if (progress.total > 0) {
                                const percentComplete = (progress.loaded / progress.total * 100);
                                console.log('GLTF加载进度: ' + percentComplete.toFixed(1) + '%');
                                document.querySelector('#loading div:last-child').textContent = 
                                    `正在加载3D模型... ${percentComplete.toFixed(1)}%`;
                            }
                        },
                        function(error) {
                            // GLTF加载失败
                            console.error('GLTF加载失败:', error);
                            URL.revokeObjectURL(url);
                            showError('GLTF解析失败: ' + error.message);
                        }
                    );
                })
                .catch(error => {
                    console.error('文件获取失败:', error);
                    
                    // 如果fetch失败，尝试直接用路径加载
                    console.log('尝试直接路径加载...');
                    
                    loader.load(
                        'w.glb',
                        function(gltf) {
                            console.log('直接路径加载成功');
                            
                            const model = gltf.scene;
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            
                            model.position.x = -center.x;
                            model.position.y = -center.y;
                            model.position.z = -center.z;
                            
                            const maxDim = Math.max(size.x, size.y, size.z);
                            camera.position.set(0, 0, maxDim * 2);
                            controls.target.set(0, 0, 0);
                            controls.minDistance = maxDim * 0.5;
                            controls.maxDistance = maxDim * 5;
                            
                            // 同样的大幅材质优化逻辑
                            model.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    if (child.material) {
                                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                                        materials.forEach(material => {
                                            if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                                                material.roughness = Math.max(0.05, material.roughness || 0.3);
                                                material.metalness = material.metalness || 0;
                                                material.envMapIntensity = 2.0;
                                            }
                                            if (material.map) {
                                                material.map.encoding = THREE.sRGBEncoding;
                                                material.map.flipY = false;
                                            }
                                            if (material.color) {
                                                const hsl = {};
                                                material.color.getHSL(hsl);
                                                let newLightness = hsl.l;
                                                if (hsl.l < 0.7) {
                                                    newLightness = Math.min(0.9, hsl.l + 0.4);
                                                }
                                                const newSaturation = Math.min(1.0, hsl.s + 0.2);
                                                material.color.setHSL(hsl.h, newSaturation, newLightness);
                                            }
                                            if (material.emissive) {
                                                material.emissive.multiplyScalar(1.5);
                                            }
                                            material.needsUpdate = true;
                                        });
                                    }
                                }
                            });
                            
                            scene.add(model);
                            loadingElement.style.display = 'none';
                            console.log('直接路径加载完成');
                        },
                        function(progress) {
                            if (progress.total > 0) {
                                const percentComplete = (progress.loaded / progress.total * 100);
                                console.log('直接加载进度: ' + percentComplete.toFixed(1) + '%');
                            }
                        },
                        function(directError) {
                            console.error('直接路径加载也失败:', directError);
                            showError(`加载失败：${error.message}\n\n可能的原因：\n1. 需要HTTP服务器 (不能直接打开HTML文件)\n2. w.glb文件损坏\n3. 文件路径不正确\n\n请确保通过HTTP服务器访问此页面`);
                        }
                    );
                });
        }

        // 显示错误信息
        function showError(message) {
            loadingElement.style.display = 'none';
            errorElement.style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新控制器
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }

        // 窗口大小变化处理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>